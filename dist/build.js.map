{"version":3,"sources":["webpack:///build.js","webpack:///webpack/bootstrap 2ca01d5c6061cc8470a1","webpack:///./src/index.js","webpack:///external \"rabbot\"","webpack:///external \"lodash\"","webpack:///external \"events\""],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","Rabbot","_","EventEmitter","ee","prefix","Wabbit","this","value","nackOnError","config","_this","Promise","resolve","reject","configure","done","debug","console","log","bindings","Array","map","exchange","ex","Exchange","q","Queue","name","keys","registerQueue","registerExchange","on","runExchange","runQueue","ready","err","warn","Error","values","exchanges","JSON","stringify","queues","queue","_this2","isArray","messages","msg","shift","type","request","publish","_this3","_this4","startSubscription","handlers","_handler","handler","route","createRouteMap","handle","result","properties","headers","reply","isUndefined","isNull","ack","_this5","emit","push","assign","routeMap","routingKey","options","body","replyTimeout","_ref","get","_debug","set","isBoolean","_routeMap","isObject","_exchanges","_messages","_ready","_class","concat","sort","uniq","apply","_name","isString","toString","_queues","_class2","opts","hasKey","isFunction","indexOf","_keys","_handlers","WabbitInstance","require"],"mappings":"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","file":"build.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(1);\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Rabbot = __webpack_require__(2),\n\t    _ = __webpack_require__(3),\n\t    EventEmitter = __webpack_require__(4).EventEmitter,\n\t    ee = new EventEmitter(),\n\t    prefix = '[WABBIT]';\n\t\n\tvar instance = null;\n\t\n\tvar Wabbit = function () {\n\t  function Wabbit() {\n\t    _classCallCheck(this, Wabbit);\n\t\n\t    instance = instance || this;\n\t    return instance;\n\t  }\n\t\n\t  _createClass(Wabbit, [{\n\t    key: 'nackOnError',\n\t    value: function nackOnError() {\n\t      Rabbot.nackOnError();\n\t    }\n\t  }, {\n\t    key: 'configure',\n\t    value: function configure(config) {\n\t      var _this = this;\n\t\n\t      // NOTE\n\t      // we will return a promise that will resolve\n\t      // after we have fully configured Rabbot AND Wabbit\n\t      // and registered all of the queues and exchanges\n\t      return new Promise(function (resolve, reject) {\n\t        Rabbot.configure(config).done(function () {\n\t          if (_this.debug) {\n\t            console.log(prefix, \"Rabbot configured.\");\n\t          }\n\t\n\t          var bindings = config.bindings;\n\t\n\t          if (!bindings || !(bindings instanceof Array) || bindings.length < 1) {\n\t            var err = \"Wabbit.configure must be passed an [Object]\";\n\t            if (_this.debug) {\n\t              console.warn(prefix, err);\n\t            }\n\t            reject(new Error(err));\n\t          } else {\n\t            bindings.map(function (config) {\n\t              if (config.exchange) {\n\t                var ex = new _this.Exchange(config.exchange);\n\t                if (config.target) {\n\t                  var q = new _this.Queue({\n\t                    name: config.target,\n\t                    keys: config.keys\n\t                  });\n\t                  ex.registerQueue(q);\n\t                }\n\t                _this.registerExchange(ex);\n\t              }\n\t            });\n\t            // now set up our listener just in case any more exchanges\n\t            // get added after this point\n\t            ee.on('register:exchange', _this.runExchange);\n\t            ee.on('register:queue', _this.runQueue);\n\t            if (_this.debug) {\n\t              console.log(prefix, \"Wabbit configured.\");\n\t            }\n\t            _this.ready = true;\n\t            resolve();\n\t          }\n\t        });\n\t      });\n\t    }\n\t  }, {\n\t    key: 'dump',\n\t    value: function dump() {\n\t      _.values(this.exchanges).map(function (exchange) {\n\t        console.log(JSON.stringify(exchange, true, 2));\n\t        _.values(exchange.queues).map(function (queue) {\n\t          console.log(JSON.stringify(queue, true, 2));\n\t        });\n\t      });\n\t    }\n\t  }, {\n\t    key: 'run',\n\t    value: function run() {\n\t      var _this2 = this;\n\t\n\t      if (!this.ready) {\n\t        var err = 'Wabbit has not been configured! Please make sure you run Wabbit.configure() first.';\n\t        if (this.debug) {\n\t          console.warn(prefix, err);\n\t        }\n\t        throw new Error(err);\n\t      }\n\t      // ensure that all queues handlers are registered with rabbitmq!\n\t      // map all queues\n\t      if (this.debug) {\n\t        console.log(prefix, \"Running exchanges...\");\n\t      }\n\t      _.values(this.exchanges).map(function (exchange) {\n\t        _this2.runExchange(exchange);\n\t      });\n\t\n\t      // everything is registered (trickle-down...)\n\t      // try to empty our messages in memory this.messages\n\t      if (this.debug) {\n\t        if (_.isArray(this.messages) && this.messages.length) {\n\t          console.log(prefix, \"Publishing stored messages.\");\n\t        }\n\t      }\n\t      var msg = null;\n\t      while (msg = this.messages.shift()) {\n\t        if (msg.type == 'request') {\n\t          this.request(msg.key, msg.msg);\n\t        } else {\n\t          this.publish(msg.key, msg.msg);\n\t        }\n\t      }\n\t    }\n\t  }, {\n\t    key: 'runExchange',\n\t    value: function runExchange(exchange) {\n\t      var _this3 = this;\n\t\n\t      if (this.debug) {\n\t        console.log(prefix, 'Running queues...');\n\t      }\n\t      _.values(exchange.queues).map(function (queue) {\n\t        _this3.runQueue(queue, exchange);\n\t      });\n\t    }\n\t  }, {\n\t    key: 'runQueue',\n\t    value: function runQueue(queue, exchange) {\n\t      var _this4 = this;\n\t\n\t      var startSubscription = _.isArray(queue.handlers) && queue.handlers.length;\n\t      if (!startSubscription) {\n\t        var key = void 0;\n\t        while (key = queue.keys.shift()) {\n\t          var route = {\n\t            key: key,\n\t            exchange: exchange.name,\n\t            queue: queue.name\n\t          };\n\t          this.createRouteMap(route);\n\t        }\n\t      } else {\n\t        queue.handlers.map(function (_handler) {\n\t          if (!_handler || !_handler.key || !_handler.handler) {\n\t            return;\n\t          }\n\t\n\t          var route = {\n\t            key: _handler.key,\n\t            exchange: exchange.name,\n\t            queue: queue.name\n\t          };\n\t          _this4.createRouteMap(route);\n\t\n\t          Rabbot.handle({\n\t            type: _handler.key,\n\t            handler: function handler(msg) {\n\t              _handler.handler(msg, function (result) {\n\t                if (msg.properties.headers.reply) {\n\t                  var reply = _.isUndefined(result) || _.isNull(result) ? { result: null } : result;\n\t                  msg.reply(reply);\n\t                } else {\n\t                  msg.ack();\n\t                }\n\t              });\n\t            }\n\t          }).catch(function (err, msg) {\n\t            if (_this4.debug) {\n\t              console.log(prefix, err);\n\t              console.log(prefix, msg);\n\t            }\n\t          });\n\t        });\n\t\n\t        // all handlers have been initialized for this queue\n\t        // we can safely start the subscription\n\t        if (this.debug) {\n\t          console.log(prefix, 'Starting subscription on:', queue.name);\n\t        }\n\t        Rabbot.startSubscription(queue.name);\n\t      }\n\t    }\n\t  }, {\n\t    key: 'registerExchange',\n\t    value: function registerExchange(exchange) {\n\t      var _this5 = this;\n\t\n\t      if (!exchange) {\n\t        return null;\n\t      }\n\t\n\t      if (this.exchanges[exchange.name]) {\n\t        // we have already registered this exchange...\n\t        // let's do ourselves a solid and register\n\t        // any queues that are registered to this incoming exchange\n\t        _.values(exchange.queues).map(function (queue) {\n\t          _this5.exchanges[exchange.name].registerQueue(queue);\n\t        });\n\t      } else {\n\t        this.exchanges[exchange.name] = exchange;\n\t        ee.emit('register:exchange', this.exchanges[exchange.name]);\n\t      }\n\t    }\n\t  }, {\n\t    key: 'request',\n\t    value: function request(key, msg) {\n\t      if (this.debug) {\n\t        console.log(prefix, 'requested:', key, msg);\n\t      }\n\t      if (!Rabbot) {\n\t        console.warn('Queueing request for delivery when Rabbot is available.');\n\t        this.messages.push(Object.assign({}, { type: 'request' }, { key: key, msg: msg }));\n\t        return;\n\t      }\n\t\n\t      var route = this.routeMap[key];\n\t      if (_.isNull(route) || _.isUndefined(route)) {\n\t        if (this.debug) {\n\t          console.log(prefix, 'no route mapped for:', key, route);\n\t        }\n\t        return;\n\t      }\n\t\n\t      var type = route.type;\n\t      var routingKey = route.routingKey;\n\t      var exchange = route.exchange;\n\t      var queue = route.queue;\n\t\n\t      var options = Object.assign({}, {\n\t        routingKey: routingKey, type: type,\n\t        body: msg,\n\t        headers: { reply: true },\n\t        replyTimeout: 2000\n\t      });\n\t      if (this.debug) {\n\t        console.log(prefix, 'requesting w/options:', JSON.stringify(options, true, 2));\n\t      }\n\t      return Rabbot.request(exchange, options);\n\t    }\n\t  }, {\n\t    key: 'publish',\n\t    value: function publish(key, msg) {\n\t      if (this.debug) {\n\t        console.log(prefix, 'published:', key, msg);\n\t      }\n\t      if (!Rabbot) {\n\t        console.warn('Queueing request for delivery when Rabbot is available.');\n\t        this.messages.push(Object.assign({}, { type: 'publish' }, { key: key, msg: msg }));\n\t        return;\n\t      }\n\t\n\t      var route = this.routeMap[key];\n\t      if (_.isNull(route) || _.isUndefined(route)) {\n\t        if (this.debug) {\n\t          console.log(prefix, 'no route mapped for:', key, route);\n\t        }\n\t        return;\n\t      }\n\t\n\t      var type = route.type;\n\t      var routingKey = route.routingKey;\n\t      var exchange = route.exchange;\n\t      var queue = route.queue;\n\t\n\t      var options = Object.assign({}, {\n\t        routingKey: routingKey, type: type,\n\t        body: msg\n\t      });\n\t      if (this.debug) {\n\t        console.log(prefix, 'publishing w/options:', JSON.stringify(options, true, 2));\n\t      }\n\t      return Rabbot.publish(exchange, options);\n\t    }\n\t  }, {\n\t    key: 'createRouteMap',\n\t    value: function createRouteMap(_ref) {\n\t      var key = _ref.key;\n\t      var queue = _ref.queue;\n\t      var exchange = _ref.exchange;\n\t\n\t      this.routeMap[key] = {\n\t        queue: queue, exchange: exchange,\n\t        routingKey: key,\n\t        type: key\n\t      };\n\t    }\n\t  }, {\n\t    key: 'debug',\n\t    get: function get() {\n\t      return this._debug || false;\n\t    },\n\t    set: function set(value) {\n\t      this._debug = _.isBoolean(value) ? value : value;\n\t    }\n\t  }, {\n\t    key: 'routeMap',\n\t    get: function get() {\n\t      if (!this._routeMap) {\n\t        this.routeMap = {};\n\t      }\n\t      return this._routeMap;\n\t    },\n\t    set: function set(value) {\n\t      this._routeMap = _.isObject(value) ? value : { value: value };\n\t    }\n\t  }, {\n\t    key: 'exchanges',\n\t    get: function get() {\n\t      if (!this._exchanges) {\n\t        this.exchanges = {};\n\t      }\n\t      return this._exchanges;\n\t    },\n\t    set: function set(value) {\n\t      this._exchanges = _.isObject(value) ? value : { value: value };\n\t    }\n\t  }, {\n\t    key: 'messages',\n\t    get: function get() {\n\t      return this._messages || [];\n\t    },\n\t    set: function set(value) {\n\t      this._messages = _.isArray(value) ? value : [value];\n\t    }\n\t  }, {\n\t    key: 'ready',\n\t    get: function get() {\n\t      return this._ready || false;\n\t    },\n\t    set: function set(value) {\n\t      this._ready = _.isBoolean(value) ? value : value;\n\t    }\n\t\n\t    ///////////////////////////////////////////\n\t    //\n\t    // a class within a class!\n\t    //\n\t\n\t  }, {\n\t    key: 'Exchange',\n\t    get: function get() {\n\t      return function () {\n\t        function _class(name) {\n\t          _classCallCheck(this, _class);\n\t\n\t          this.name = name;\n\t        }\n\t\n\t        _createClass(_class, [{\n\t          key: 'registerQueue',\n\t          value: function registerQueue(queue) {\n\t            if (!queue) {\n\t              return null;\n\t            }\n\t\n\t            // we have already registered this queue...\n\t            // let's do ourselves a solid and add any\n\t            // routing keys and handlers that are listed in the incoming queue\n\t            if (this.queues[queue.name]) {\n\t              // keys\n\t              var keys = this.queues[queue.name].keys.concat(queue.keys);\n\t              keys.sort();\n\t              this.queues[queue.name].keys = _.uniq(keys, true);\n\t              // handlers\n\t              Array.prototype.push.apply(this.queues[queue.name].handlers, queue.handlers);\n\t            } else {\n\t              this.queues[queue.name] = queue;\n\t              ee.emit('register:queue', this.queues[queue.name]);\n\t            }\n\t          }\n\t        }, {\n\t          key: 'getQueue',\n\t          value: function getQueue(name) {\n\t            return this.queues[name];\n\t          }\n\t        }, {\n\t          key: 'name',\n\t          get: function get() {\n\t            return this._name;\n\t          },\n\t          set: function set(value) {\n\t            this._name = _.isString(value) ? value : value.toString();\n\t          }\n\t        }, {\n\t          key: 'queues',\n\t          get: function get() {\n\t            if (!this._queues) {\n\t              this.queues = {};\n\t            }\n\t            return this._queues;\n\t          },\n\t          set: function set(value) {\n\t            this._queues = _.isObject(value) ? value : { value: value };\n\t          }\n\t        }]);\n\t\n\t        return _class;\n\t      }();\n\t    }\n\t\n\t    ///////////////////////////////////////////\n\t    //\n\t    // a class within a class!\n\t    //\n\t\n\t  }, {\n\t    key: 'Queue',\n\t    get: function get() {\n\t      return function () {\n\t        function _class2(opts) {\n\t          _classCallCheck(this, _class2);\n\t\n\t          this.name = opts.name;\n\t          this.keys = opts.keys;\n\t        }\n\t\n\t        _createClass(_class2, [{\n\t          key: 'registerHandler',\n\t          value: function registerHandler(opts) {\n\t            if (!opts || !_.isObject(opts)) {\n\t              throw new Error(500, 'Queue.handler options must be an [Object] with properties {key, handler}');\n\t            }\n\t\n\t            var key = opts.key;\n\t            var handler = opts.handler;\n\t\n\t            if (!key || !this.hasKey(key)) {\n\t              throw new Error(501, 'Queue.handler routing key [' + key + '] is not available on this queue');\n\t            }\n\t            if (!handler || !_.isFunction(handler)) {\n\t              throw new Error(502, 'Queue.handler handler function must be of type [Function]');\n\t            }\n\t\n\t            this.handlers.push({ key: key, handler: handler });\n\t          }\n\t        }, {\n\t          key: 'hasKey',\n\t          value: function hasKey(key) {\n\t            return this.keys.indexOf(key) > -1;\n\t          }\n\t        }, {\n\t          key: 'name',\n\t          get: function get() {\n\t            return this._name;\n\t          },\n\t          set: function set(value) {\n\t            this._name = _.isString(value) ? value : value.toString();\n\t          }\n\t        }, {\n\t          key: 'keys',\n\t          get: function get() {\n\t            if (!this._keys) {\n\t              this.keys = [];\n\t            }\n\t            return this._keys;\n\t          },\n\t          set: function set(value) {\n\t            this._keys = _.isArray(value) ? value : [value];\n\t          }\n\t        }, {\n\t          key: 'handlers',\n\t          get: function get() {\n\t            if (!this._handlers) {\n\t              this.handlers = [];\n\t            }\n\t            return this._handlers;\n\t          },\n\t          set: function set(value) {\n\t            this._handlers = _.isArray(value) ? value : [value];\n\t          }\n\t        }]);\n\t\n\t        return _class2;\n\t      }();\n\t    }\n\t  }]);\n\t\n\t  return Wabbit;\n\t}();\n\t\n\tvar WabbitInstance = new Wabbit();\n\tmodule.exports = WabbitInstance;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"rabbot\");\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"lodash\");\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"events\");\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** build.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 2ca01d5c6061cc8470a1\n **/","const Rabbot = require('rabbot'),\n  _ = require('lodash'),\n  EventEmitter = require('events').EventEmitter,\n  ee = new EventEmitter(),\n  prefix = '[WABBIT]'\n\nlet instance = null\n\nclass Wabbit {\n  constructor(){\n    instance = instance || this\n    return instance\n  }\n\n  nackOnError(){\n    Rabbot.nackOnError()\n  }\n\n  get debug(){\n    return this._debug || false\n  }\n  set debug(value){\n    this._debug = _.isBoolean(value) ? value : (value)\n  }\n\n  configure(config){\n    // NOTE\n    // we will return a promise that will resolve\n    // after we have fully configured Rabbot AND Wabbit\n    // and registered all of the queues and exchanges\n    return new Promise((resolve, reject)=>{\n      Rabbot.configure(config)\n        .done(()=>{\n          if( this.debug ){\n            console.log(prefix, \"Rabbot configured.\")\n          }\n\n          const {bindings} = config\n          if( !bindings || !(bindings instanceof Array) || (bindings.length < 1) ){\n            const err = \"Wabbit.configure must be passed an [Object]\"\n            if( this.debug ){\n              console.warn(prefix, err)\n            }\n            reject(new Error(err))\n          } else {\n            bindings.map((config)=>{\n              if( config.exchange ){\n                let ex = new this.Exchange(config.exchange)\n                if( config.target ){\n                  let q = new this.Queue({\n                    name: config.target,\n                    keys: config.keys\n                  })\n                  ex.registerQueue(q)\n                }\n                this.registerExchange(ex)\n              }\n            })\n            // now set up our listener just in case any more exchanges\n            // get added after this point\n            ee.on('register:exchange', this.runExchange)\n            ee.on('register:queue', this.runQueue)\n            if( this.debug ){\n              console.log(prefix, \"Wabbit configured.\")\n            }\n            this.ready = true\n            resolve()\n          }\n        })\n    })\n  }\n\n  dump(){\n    _.values(this.exchanges).map((exchange)=>{\n      console.log(JSON.stringify(exchange, true, 2))\n      _.values(exchange.queues).map((queue)=>{\n        console.log(JSON.stringify(queue, true, 2))\n      })\n    })\n  }\n\n  run(){\n    if( !this.ready ){\n      const err = 'Wabbit has not been configured! Please make sure you run Wabbit.configure() first.'\n      if( this.debug ){\n        console.warn(prefix, err)\n      }\n      throw new Error(err)\n    }\n    // ensure that all queues handlers are registered with rabbitmq!\n    // map all queues\n    if( this.debug ){\n      console.log(prefix, \"Running exchanges...\")\n    }\n    _.values(this.exchanges).map((exchange)=>{\n      this.runExchange(exchange)\n    })\n\n    // everything is registered (trickle-down...)\n    // try to empty our messages in memory this.messages\n    if( this.debug ){\n      if( _.isArray(this.messages) && this.messages.length ){\n        console.log(prefix, \"Publishing stored messages.\")\n      }\n    }\n    let msg = null\n    while( msg = this.messages.shift() ){\n      if( msg.type == 'request' ){\n        this.request(msg.key, msg.msg)\n      } else {\n        this.publish(msg.key, msg.msg)\n      }\n    }\n  }\n\n  runExchange(exchange){\n    if( this.debug ){\n      console.log(prefix, 'Running queues...')\n    }\n    _.values(exchange.queues).map((queue)=>{\n      this.runQueue(queue, exchange)\n    })\n  }\n\n  runQueue(queue, exchange){\n    const startSubscription = (_.isArray(queue.handlers) && queue.handlers.length)\n    if( !startSubscription ){\n      let key\n      while( key = queue.keys.shift() ){\n        const route = {\n          key,\n          exchange: exchange.name,\n          queue: queue.name\n        }\n        this.createRouteMap(route)\n      }\n    } else {\n      queue.handlers.map((handler)=>{\n        if( !handler || !handler.key || !handler.handler ){\n          return\n        }\n\n        const route = {\n          key: handler.key,\n          exchange: exchange.name,\n          queue: queue.name\n        }\n        this.createRouteMap(route)\n\n        Rabbot\n          .handle({\n            type: handler.key,\n            handler(msg){\n              handler.handler(msg, (result)=>{\n                if( msg.properties.headers.reply ){\n                  const reply = _.isUndefined(result) || _.isNull(result) ? {result:null} : result\n                  msg.reply(reply)\n                } else {\n                  msg.ack()\n                }\n              })\n            }\n          })\n          .catch((err, msg)=>{\n            if( this.debug ){\n              console.log(prefix, err)\n              console.log(prefix, msg)\n            }\n          })\n      })\n\n      // all handlers have been initialized for this queue\n      // we can safely start the subscription\n      if( this.debug ){\n        console.log(prefix, 'Starting subscription on:', queue.name)\n      }\n      Rabbot.startSubscription(queue.name)\n    }\n  }\n\n  registerExchange(exchange){\n    if( !exchange ){\n      return null\n    }\n\n    if( this.exchanges[exchange.name] ){\n      // we have already registered this exchange...\n      // let's do ourselves a solid and register\n      // any queues that are registered to this incoming exchange\n      _.values(exchange.queues).map((queue)=>{\n        this.exchanges[exchange.name].registerQueue(queue)\n      })\n    } else {\n      this.exchanges[exchange.name] = exchange\n      ee.emit('register:exchange', this.exchanges[exchange.name])\n    }\n  }\n\n  request(key, msg){\n    if( this.debug ){\n      console.log(prefix, 'requested:', key, msg)\n    }\n    if( !Rabbot ){\n      console.warn('Queueing request for delivery when Rabbot is available.')\n      this.messages.push(Object.assign({}, {type:'request'}, {key, msg}))\n      return\n    }\n\n    const route = this.routeMap[key]\n    if( _.isNull(route) || _.isUndefined(route) ){\n      if( this.debug ){\n        console.log(prefix, 'no route mapped for:', key, route)\n      }\n      return\n    }\n\n    const {type, routingKey, exchange, queue} = route\n    const options = Object.assign({},{\n      routingKey, type,\n      body: msg,\n      headers: {reply: true},\n      replyTimeout: 2000\n    })\n    if( this.debug ){\n      console.log(prefix, 'requesting w/options:', JSON.stringify(options, true, 2))\n    }\n    return Rabbot.request(exchange, options)\n  }\n\n  publish(key, msg){\n    if( this.debug ){\n      console.log(prefix, 'published:', key, msg)\n    }\n    if( !Rabbot ){\n      console.warn('Queueing request for delivery when Rabbot is available.')\n      this.messages.push(Object.assign({}, {type:'publish'}, {key, msg}))\n      return\n    }\n\n    const route = this.routeMap[key]\n    if( _.isNull(route) || _.isUndefined(route) ){\n      if( this.debug ){\n        console.log(prefix, 'no route mapped for:', key, route)\n      }\n      return\n    }\n\n    const {type, routingKey, exchange, queue} = route\n    const options = Object.assign({},{\n      routingKey, type,\n      body: msg\n    })\n    if( this.debug ){\n      console.log(prefix, 'publishing w/options:', JSON.stringify(options, true, 2))\n    }\n    return Rabbot.publish(exchange, options)\n  }\n\n  createRouteMap({key, queue, exchange}){\n    this.routeMap[key] = {\n      queue, exchange,\n      routingKey: key,\n      type: key\n    }\n  }\n\n  get routeMap(){\n    if( !this._routeMap ){\n      this.routeMap = {}\n    }\n    return this._routeMap\n  }\n  set routeMap(value){\n    this._routeMap = _.isObject(value) ? value : {value}\n  }\n\n  get exchanges(){\n    if( !this._exchanges ){\n      this.exchanges = {}\n    }\n    return this._exchanges\n  }\n  set exchanges(value){\n    this._exchanges = _.isObject(value) ? value : {value}\n  }\n\n  get messages(){\n    return this._messages || []\n  }\n  set messages(value){\n    this._messages = _.isArray(value) ? value : [value]\n  }\n\n  get ready(){\n    return this._ready || false\n  }\n  set ready(value){\n    this._ready = _.isBoolean(value) ? value : (value)\n  }\n\n  ///////////////////////////////////////////\n  //\n  // a class within a class!\n  //\n  get Exchange(){\n    return class {\n      constructor(name){\n        this.name = name\n      }\n\n      registerQueue(queue){\n        if( !queue ){\n          return null\n        }\n\n        // we have already registered this queue...\n        // let's do ourselves a solid and add any\n        // routing keys and handlers that are listed in the incoming queue\n        if( this.queues[queue.name] ){\n          // keys\n          let keys = this.queues[queue.name].keys.concat(queue.keys)\n          keys.sort()\n          this.queues[queue.name].keys = _.uniq(keys, true)\n          // handlers\n          Array.prototype.push.apply(this.queues[queue.name].handlers, queue.handlers)\n        } else {\n          this.queues[queue.name] = queue\n          ee.emit('register:queue', this.queues[queue.name])\n        }\n      }\n\n      getQueue(name){\n        return this.queues[name]\n      }\n\n      get name(){\n        return this._name\n      }\n      set name(value){\n        this._name = _.isString(value) ? value : value.toString()\n      }\n\n      get queues(){\n        if( !this._queues ){\n          this.queues = {}\n        }\n        return this._queues\n      }\n      set queues(value){\n        this._queues = _.isObject(value) ? value : {value}\n      }\n    }\n  }\n\n  ///////////////////////////////////////////\n  //\n  // a class within a class!\n  //\n  get Queue(){\n    return class {\n      constructor(opts){\n        this.name = opts.name\n        this.keys = opts.keys\n      }\n\n      registerHandler(opts){\n        if( !opts || !_.isObject(opts) ){\n          throw new Error(500, `Queue.handler options must be an [Object] with properties {key, handler}`)\n        }\n\n        const {key, handler} = opts\n        if( !key || !this.hasKey(key) ){\n          throw new Error(501, `Queue.handler routing key [${key}] is not available on this queue`)\n        }\n        if( !handler || !_.isFunction(handler) ){\n          throw new Error(502, `Queue.handler handler function must be of type [Function]`)\n        }\n\n        this.handlers.push({key, handler})\n      }\n\n      get name(){\n        return this._name\n      }\n      set name(value){\n        this._name = _.isString(value) ? value : value.toString()\n      }\n\n      get keys(){\n        if( !this._keys ){\n          this.keys = []\n        }\n        return this._keys\n      }\n      set keys(value){\n        this._keys = _.isArray(value) ? value : [value]\n      }\n\n      hasKey(key){\n        return (this.keys.indexOf(key) > -1)\n      }\n\n      get handlers(){\n        if( !this._handlers ){\n          this.handlers = []\n        }\n        return this._handlers\n      }\n      set handlers(value){\n        this._handlers = _.isArray(value) ? value : [value]\n      }\n    }\n  }\n}\n\nconst WabbitInstance = new Wabbit()\nmodule.exports = WabbitInstance\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","module.exports = require(\"rabbot\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"rabbot\"\n ** module id = 2\n ** module chunks = 0\n **/","module.exports = require(\"lodash\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"lodash\"\n ** module id = 3\n ** module chunks = 0\n **/","module.exports = require(\"events\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"events\"\n ** module id = 4\n ** module chunks = 0\n **/"],"sourceRoot":""}